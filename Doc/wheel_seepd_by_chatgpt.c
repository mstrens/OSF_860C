//#define DISPLAY_CODE  // remove comment to see the c code
#ifdef DISPLAY_CODE
// Code generated by chatgpt to manage the wheel sensor with a minimum of cycles in the 19kHz isr
// speed is calculated in a slow loop that read a buffer with several timestamps if the loop is to low.
// this code has still to be adapted to calculate a number of ticks like the mbrusa code

// there is also some code in order to update automatically the table with hall positions
//    but only if speed is high enough and stable on several electric tours
#include <stdint.h>
#include <stdbool.h>

// ====================
// Paramètres
// ====================
#define BUFFER_SIZE 32
#define WHEEL_DIAMETER_MM 508         // 20 pouces = 508 mm
#define SPEED_THRESHOLD_KMH 2         // seuil sous lequel -> 0 km/h

// ====================
// Constantes calculées
// ====================
#define WHEEL_CIRCUMFERENCE_MM ((31416L * WHEEL_DIAMETER_MM) / 10000L)  
// π * D, en mm (≈1595 mm)

// ====================
// Structures et buffers
// ====================
typedef struct {
    uint32_t timestamp;  // en ticks (timer étendu)
} Event;

static volatile Event buffer[BUFFER_SIZE];
static volatile uint8_t buf_head = 0;
static volatile uint8_t buf_tail = 0;

static volatile uint16_t timer16 = 0;        // valeur du timer HW
static volatile uint32_t overflow_count = 0; // compteur d’overflows

static uint8_t last_gpio_state = 0;

// Horloge étendue (32 bits en ticks)
static inline uint32_t get_extended_time(uint16_t t) {
    return (overflow_count << 16) | t;
}

// ====================
// ISR 19 kHz
// ====================
void loop_fast_19khz_ISR(void) {
    uint8_t gpio_state = read_gpio();   // TODO: adapter à ton MCU
    uint16_t t = read_timer16();        // TODO: lecture du timer HW

    // Gérer overflow du timer 16 bits
    static uint16_t prev_timer = 0;
    if (t < prev_timer) {
        overflow_count++;
    }
    prev_timer = t;

    // Détection front montant
    if ((gpio_state == 1) && (last_gpio_state == 0)) {
        uint32_t ts = get_extended_time(t);

        uint8_t next_head = (buf_head + 1) % BUFFER_SIZE;
        if (next_head != buf_tail) {
            buffer[buf_head].timestamp = ts;
            buf_head = next_head;
        }
        // sinon buffer plein -> on ignore
    }
    last_gpio_state = gpio_state;
}

// ====================
// Lecture buffer en boucle lente
// ====================
static bool get_next_event(uint32_t *ts) {
    if (buf_tail == buf_head) {
        return false; // vide
    }
    *ts = buffer[buf_tail].timestamp;
    buf_tail = (buf_tail + 1) % BUFFER_SIZE;
    return true;
}

// ====================
// Calcul vitesse (km/h *100 pour garder de la précision)
// ====================
// clk_timer_hz = fréquence du timer HW (ex. 1 MHz -> 1 tick = 1 µs)
int32_t compute_speed(uint8_t N, uint32_t clk_timer_hz) {
    static uint32_t last_ts = 0;
    static uint32_t last_event_time = 0;
    static int32_t last_speed = 0; // km/h *100

    uint32_t ts;

    // seuil en ticks = temps max entre impulsions correspondant à SPEED_THRESHOLD_KMH
    uint64_t num = (uint64_t)WHEEL_CIRCUMFERENCE_MM * 3600000ULL * N;
    uint32_t max_period_ticks = (uint32_t)(num / (SPEED_THRESHOLD_KMH * (uint64_t)clk_timer_hz));

    // Nouvel événement ?
    if (get_next_event(&ts)) {
        if (last_ts != 0) {
            uint32_t delta = ts - last_ts;
            last_ts = ts;
            last_event_time = ts;

            if (delta > max_period_ticks) {
                last_speed = 0;
                return 0;
            }

            // vitesse = (C * clk * 3.6) / (delta * N * 1000)
            uint64_t num2 = (uint64_t)WHEEL_CIRCUMFERENCE_MM * clk_timer_hz * 36ULL;
            int32_t speed = (int32_t)(num2 / ((uint64_t)delta * N * 10ULL)); // km/h *100

            last_speed = speed;
            return speed;
        } else {
            // premier événement
            last_ts = ts;
            last_event_time = ts;
            last_speed = 0;
            return 0;
        }
    }

    // Pas de nouvel événement -> vérifier timeout
    uint32_t now = get_extended_time(read_timer16());
    if ((now - last_event_time) > max_period_ticks) {
        last_speed = 0;
        return 0;
    }

    return last_speed;
}
//========================= version valable à la fois pour wheel speed and cadence
/*
Parfait ! Voici une version complète et cohérente pour Cortex-M0 qui gère à la fois :

Vitesse roue (1 GPIO ou plusieurs aimants).

Cadence pédalier (2 GPIO en quadrature, sens détecté).

Le code est structuré pour :

ISR unique à 19 kHz, ultra légère pour chaque capteur.

Buffers séparés pour roue et pédalier.

Boucle lente qui peut être retardée 100 ms, calcule : vitesse roue en km/h et cadence pédale en RPM.

Timeout automatique → vitesse ou cadence tombe à 0 si pas d’impulsion récente.

Direction pédalier respectée → ignore impulsions dans le sens inverse.
*/
#include <stdint.h>
#include <stdbool.h>

// ====================
// Paramètres
// ====================
#define WHEEL_BUFFER_SIZE 32
#define WHEEL_DIAMETERS_M 0.508f     // 20 pouces
#define WHEEL_MAX_AIMANTS 8

#define CADENCE_BUFFER_SIZE 32
#define CADENCE_IMPULSES_PER_REV 20
#define CADENCE_THRESHOLD_RPM 5
#define EXPECTED_DIR 1               // pédalage normal

// ====================
// Variables partagées
// ====================
static volatile uint32_t wheel_buffer[WHEEL_BUFFER_SIZE];
static volatile uint8_t wheel_head = 0, wheel_tail = 0;

static volatile uint32_t cadence_buffer[CADENCE_BUFFER_SIZE];
static volatile uint8_t cadence_head = 0, cadence_tail = 0;

static volatile uint16_t timer16 = 0;
static volatile uint32_t overflow_count = 0;

static uint8_t last_wheel_state = 0;
static uint8_t last_gpio_a = 0, last_gpio_b = 0;

// ====================
// Fonctions utilitaires
// ====================
static inline uint32_t get_extended_time(uint16_t t) {
    return (overflow_count << 16) | t;
}

// ====================
// ISR 19 kHz
// ====================
void loop_fast_19khz_ISR(void) {
    uint16_t t = read_timer16(); // même timer pour roue et pédalier

    // Gérer overflow
    static uint16_t prev_timer = 0;
    if (t < prev_timer) overflow_count++;
    prev_timer = t;

    // ---------- Roue ----------
    uint8_t wheel_gpio = read_gpio_wheel();
    if (wheel_gpio == 1 && last_wheel_state == 0) {
        uint32_t ts = get_extended_time(t);
        uint8_t next = (wheel_head + 1) & (WHEEL_BUFFER_SIZE-1);
        if (next != wheel_tail) {
            wheel_buffer[wheel_head] = ts;
            wheel_head = next;
        }
    }
    last_wheel_state = wheel_gpio;

    // ---------- Pédalier ----------
    // this could be moved up to read all gpio in one read
    uint8_t gpio_a = read_gpio_a();
    uint8_t gpio_b = read_gpio_b();

    if (gpio_a == 1 && last_gpio_a == 0) {
        int8_t dir = (gpio_b == 1) ? +1 : -1;
        if (dir == EXPECTED_DIR) {  // stocker uniquement sens correct
            uint32_t ts = get_extended_time(t);
            uint8_t next = (cadence_head + 1) & (CADENCE_BUFFER_SIZE - 1);
            if (next != cadence_tail) {
                cadence_buffer[cadence_head] = ts;
                cadence_head = next;
            }
        }
    }
    last_gpio_a = gpio_a;
    last_gpio_b = gpio_b;
}

// ====================
// Lecture buffer roue
// ====================
static bool get_next_wheel_event(uint32_t *ts) {
    if (wheel_tail == wheel_head) return false;
    *ts = wheel_buffer[wheel_tail];
    wheel_tail = (wheel_tail + 1) % WHEEL_BUFFER_SIZE;
    return true;
}

// ====================
// Lecture buffer pédalier
// ====================
static bool get_next_cad_event(uint32_t *ts) {
    if (cadence_tail == cadence_head) return false;
    *ts = cadence_buffer[cadence_tail];
    cadence_tail = (cadence_tail + 1) % CADENCE_BUFFER_SIZE;
    return true;
}

// ====================
// Calcul vitesse roue (km/h *100)
// ====================
int32_t compute_wheel_speed(uint32_t clk_timer_hz, uint8_t N_aimants) {
    static uint32_t last_ts = 0;
    static uint32_t last_event_time = 0;
    static int32_t last_speed = 0;

    uint32_t ts;
    float min_speed = 2.0f;
    uint32_t circ_mm = (uint32_t)(3.14159f * WHEEL_DIAMETERS_M * 1000);
    uint64_t num_ticks = (uint64_t)circ_mm * clk_timer_hz * 3600ULL;
    uint32_t max_period_ticks = (uint32_t)(num_ticks / (min_speed * N_aimants * 1000ULL));

    if (get_next_wheel_event(&ts)) {
        if (last_ts != 0) {
            uint32_t delta = ts - last_ts;
            last_ts = ts;
            last_event_time = ts;

            if (delta > max_period_ticks) {
                last_speed = 0;
                return 0;
            }

            uint64_t num2 = (uint64_t)circ_mm * clk_timer_hz * 360ULL;
            int32_t speed = (int32_t)(num2 / ((uint64_t)delta * N_aimants * 10ULL));
            last_speed = speed;
            return speed;
        } else {
            last_ts = ts;
            last_event_time = ts;
            last_speed = 0;
            return 0;
        }
    }

    uint32_t now = get_extended_time(read_timer16());
    if ((now - last_event_time) > max_period_ticks) last_speed = 0;
    return last_speed;
}

// ====================
// Calcul cadence pédalier (RPM*100)
// ====================
int32_t compute_cadence(uint32_t clk_timer_hz) {
    static uint32_t last_ts = 0;
    static uint32_t last_event_time = 0;
    static int32_t last_rpm = 0;

    uint32_t ts;
    uint64_t num = 60ULL * clk_timer_hz;
    uint32_t max_period_ticks = (uint32_t)(num / (CADENCE_THRESHOLD_RPM * CADENCE_IMPULSES_PER_REV));

    if (get_next_cad_event(&ts)) {
        if (last_ts != 0) {
            uint32_t delta = ts - last_ts;
            last_ts = ts;
            last_event_time = ts;

            if (delta > max_period_ticks) {
                last_rpm = 0;
                return 0;
            }

            uint64_t num2 = 60ULL * clk_timer_hz * 100ULL;
            int32_t rpm = (int32_t)(num2 / ((uint64_t)delta * CADENCE_IMPULSES_PER_REV));
            last_rpm = rpm;
            return rpm;
        } else {
            last_ts = ts;
            last_event_time = ts;
            last_rpm = 0;
            return 0;
        }
    }

    uint32_t now = get_extended_time(read_timer16());
    if ((now - last_event_time) > max_period_ticks) last_rpm = 0;
    return last_rpm;
}

/*
✅ Points clés

ISR unique et légère :

Roue + pédalier.

ISR ne stocke que ce qui est nécessaire → sens correct pour pédalier.

Buffers séparés :

Roue → timestamps uniquement.

Pédalier → timestamps uniquement pour sens correct.

Boucle lente :

Calcul vitesse et cadence.

Timeout automatique → valeur = 0 si pas d’impulsions.

Optimisation Cortex-M0 :

Tous les accès partagés volatile.

Buffers circulaires sûrs, pas besoin de désactiver les IRQ. 
*/



========== here some code to automatically update the LUT with hall angles
#include <stdint.h>
#include <stdbool.h>

#define HALL_COMBINATIONS      6
#define BUFFER_SIZE            60
#define DELTAS_PER_HALL        (BUFFER_SIZE / HALL_COMBINATIONS)  // 10
#define MIN_RPM                1000
#define MAX_VARIATION_PERCENT  10
#define LUT_SMOOTHING_FACTOR   200    // facteur sur 1000 pour le lissage
#define ANGLE_Q16_FULL         (1U << 16)  // 360° en Q16

// LUT des angles en Q16
uint32_t hall_angle_LUT[HALL_COMBINATIONS] = {0};

// Buffer des intervalles en microsecondes
uint32_t delta_buffer[BUFFER_SIZE];
uint32_t last_hall_timestamp = 0;
uint8_t buffer_count = 0;

// ISR à appeler sur chaque changement Hall
void ISR_Hall(uint32_t timestamp, uint8_t hall_idx) {
    uint32_t delta = timestamp - last_hall_timestamp;
    last_hall_timestamp = timestamp;

    if (buffer_count < BUFFER_SIZE) {
        uint8_t write_index = hall_idx + buffer_count;
        if (write_index >= BUFFER_SIZE)
            write_index -= BUFFER_SIZE;
        delta_buffer[write_index] = delta;
        buffer_count++;
    }
}

// Fonction périodique (toutes les 100 ms ou plus)
void Update_LUT_periodic(void) {
    if (buffer_count < BUFFER_SIZE)
        return;  // pas assez de données

    uint32_t somme_deltas[HALL_COMBINATIONS] = {0};
    uint32_t max_deltas[HALL_COMBINATIONS] = {0};
    uint32_t min_deltas[HALL_COMBINATIONS];
    for (int i = 0; i < HALL_COMBINATIONS; i++)
        min_deltas[i] = 0xFFFFFFFF;

    // Sommes et max/min par Hall
    for (int i = 0; i < BUFFER_SIZE; i++) {
        uint8_t idx = i % HALL_COMBINATIONS;  // modulo hors ISR
        uint32_t delta = delta_buffer[i];
        somme_deltas[idx] += delta;
        if (delta > max_deltas[idx]) max_deltas[idx] = delta;
        if (delta < min_deltas[idx]) min_deltas[idx] = delta;
    }

    bool stable = true;
    uint32_t somme_total = 0;
    uint32_t moyenne_deltas[HALL_COMBINATIONS];

    for (int i = 0; i < HALL_COMBINATIONS; i++) {
        moyenne_deltas[i] = somme_deltas[i] / DELTAS_PER_HALL;
        somme_total += moyenne_deltas[i];
        uint32_t variation = (max_deltas[i] - min_deltas[i]) * 100 / moyenne_deltas[i];
        if (variation > MAX_VARIATION_PERCENT)
            stable = false;
    }

    // Calcul RPM
    uint32_t rpm = 60UL * 1000000UL * HALL_COMBINATIONS / somme_total;
    if (rpm < MIN_RPM)
        stable = false;

    if (stable) {
        uint32_t angle_accum = 0;
        for (int i = 0; i < HALL_COMBINATIONS; i++) {
            // Calcul Q16 avec multiplication 64 bits pour éviter débordement
            uint32_t new_angle = (uint32_t)(((uint64_t)angle_accum * ANGLE_Q16_FULL) / somme_total);

            // Lissage Q16
            hall_angle_LUT[i] = (hall_angle_LUT[i] * (1000 - LUT_SMOOTHING_FACTOR)
                                + new_angle * LUT_SMOOTHING_FACTOR) / 1000;

            angle_accum += moyenne_deltas[i];
        }
    }

    buffer_count = 0;  // reset pour le prochain lot
}



========================= détermination des PWM avec une table LUT sur base de l'angle et de l'amplitude

#include <stdint.h>

#define LUT_SIZE 360
#define ARR      1599      // Timer auto-reload pour 20kHz, f_timer=64MHz
#define PWM_MAX  4096      // 2^12 pour shift rapide
#define AMP_DEN  1024      // puissance de 2 pour shift rapide

extern const int16_t lut_thipwm[LUT_SIZE]; // générée offline

// lut_val: -2048..+2047
// amp_num: 0..AMP_DEN
static inline uint16_t lut_amp_to_ccr_shift(int16_t lut_val, uint16_t amp_num) {
    // applique amplitude fractionnaire (division remplacée par shift si AMP_DEN = 1024)
    int32_t scaled = ((int32_t)lut_val * amp_num + (AMP_DEN>>1)) >> 10; // >>10 = /1024

    // recentre autour de 50% et conversion timer (division par PWM_MAX remplacée par >>12)
    int32_t tmp = ((int32_t)scaled + (PWM_MAX>>1)) * ARR;
    uint16_t ccr = (uint16_t)(tmp >> 12);  // >>12 remplace /PWM_MAX

    if(ccr > ARR) ccr = ARR;
    return ccr;
}

Générer les 3 PWM pour du center aligned (ici 1599 es basé sur 20Khz avec timer à 64Mhz)
Il faut donc encore adapter un define pour du 19Khz

// theta_idx: index LUT 0..LUT_SIZE-1
// amp_num: 0..AMP_DEN
// ccr: tableau de 3 uint16_t pour CCR1, CCR2, CCR3
static inline void get_pwm_ccr(uint16_t theta_idx, uint16_t amp_num, uint16_t *ccr) {
    theta_idx %= LUT_SIZE;
    uint16_t shift120 = LUT_SIZE / 3;

    uint16_t idxA = theta_idx;
    uint16_t idxB = (theta_idx + LUT_SIZE - shift120) % LUT_SIZE;
    uint16_t idxC = (theta_idx + shift120) % LUT_SIZE;

    ccr[0] = lut_amp_to_ccr_shift(lut_thipwm[idxA], amp_num); // phase A
    ccr[1] = lut_amp_to_ccr_shift(lut_thipwm[idxB], amp_num); // phase B
    ccr[2] = lut_amp_to_ccr_shift(lut_thipwm[idxC], amp_num); // phase C
}


========== ici une variante avec lut sur un seul quadran (on peut augmenter LUT_SIZE)
#include <stdint.h>

#define LUT_SIZE 256         // 0..90°, puissance de 2 pour masque rapide
#define ARR      1680        // Timer auto-reload pour 19 kHz
#define PWM_MAX  1680        // Timer auto-reload pour 19kHz avec une clock à 64Mhz et mode center aligned 
#define AMP_DEN  256        // puissance de 2 pour shift rapide
// la LUT est construite pour rester dans le range 0...800 et donc pour que PWM ne se rapproche pas des limites (0 1680) 

extern const int16_t lut_quadrant[LUT_SIZE]; // générée offline ; contient les valeurs PWM dans le range 0 800 (pour 0 90°)

static inline uint16_t lut_amp_to_ccr_shift(int16_t lut_val, uint8_t amp_num) {
    // Applique amplitude fractionnaire (shift rapide si AMP_DEN = 256 = >> 8)
    int32_t scaled = ((int32_t)lut_val * amp_num + (AMP_DEN>>1)) >> 8;
    uint16_t ccr = (uint16_t)((PWM_MAX >> 1) + scaled);

    //if (ccr >= PWM_MAX ) ccr = PWM_MAX - 10;
    return ccr;
}

static inline int16_t get_lut_value_q16(uint16_t theta_q16) {
    // Quadrant : 2 bits MSB de Q16
    uint32_t quadrant = theta_q16 >> 14;             // 16 bits → 4 quadrants
    uint32_t idx = (theta_q16 >> 6) & (LUT_SIZE - 1); // 256 points → masque 0xFF

    switch (quadrant) {
        case 0: return lut_quadrant[idx];                  // 0..90°
        case 1: return lut_quadrant[LUT_SIZE - 1 - idx];   // 90..180°
        case 2: return -lut_quadrant[idx];                 // 180..270°
        case 3: return -lut_quadrant[LUT_SIZE - 1 - idx];  // 270..360°
        default: return 0;
    }
}

// theta_q16 is in range 0 1<<16 for 0 360°
// amp_num est 0..255. 255 ≈ 99.6% car on divise par 256.
static inline void get_pwm_ccr_q16(uint16_t theta_q16, uint8_t amp_num, uint16_t *ccr) {
    // Déphasages ±120° en Q16
    uint16_t thetaA = theta_q16;
    uint16_t thetaB = theta_q16 + 0xAAAA; // -120° ≡ +240°
    uint16_t thetaC = theta_q16 + 0x5555; // +120°

    ccr[0] = lut_amp_to_ccr_shift(get_lut_value_q16(thetaA), amp_num);
    ccr[1] = lut_amp_to_ccr_shift(get_lut_value_q16(thetaB), amp_num);
    ccr[2] = lut_amp_to_ccr_shift(get_lut_value_q16(thetaC), amp_num);
}

#ifndef LUT_QUADRANT_H
#define LUT_QUADRANT_H

#include <stdint.h>

// LUT THIPWM 0..90°, range 0 ... 800 , 256 points
// Générée pour une sinusoïde THIPWM
// Index 0 = 0°, index 255 = presque 90°
const int16_t lut_quadrant[256] = {
    0,9,17,26,34,42,51,59, 68,76,85,93,102,110,118,127,
135,144,152,160,168,177,185,193,201,210,218,226,234,242,250,258,
266,274,282,289,297,305,313,320,328,335,343,350,358,365,373,380,
387,394,402,409,416,423,430,436,443,450,457,463,470,477,483,489,
496,502,508,514,521,527,533,538,544,550,556,561,567,573,578,583,
589,594,599,604,609,614,619,624,629,633,638,643,647,651,656,660,
664,668,672,676,680,684,688,692,695,699,702,706,709,712,716,719,
722,725,728,731,733,736,739,741,744,747,749,751,754,756,758,760,
762,764,766,768,770,771,773,775,776,778,779,781,782,783,784,786,
787,788,789,790,791,792,792,793,794,795,795,796,796,797,797,798,
798,798,799,799,799,799,800,800,800,800,800,800,800,800,800,800,
800,799,799,799,799,799,798,798,798,797,797,797,796,796,795,795,
795,794,794,793,793,792,792,791,791,790,790,789,788,788,787,787,
786,786,785,785,784,784,783,783,782,781,781,780,780,779,779,778,
778,778,777,777,776,776,775,775,775,774,774,774,773,773,773,772,
772,772,771,771,771,771,771,771,770,770,770,770,770,770,770,770
};

#endif // LUT_QUADRANT_H




#endif
